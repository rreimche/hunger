//
//  LocationManager.swift
//  Hunger
//
//  Adapted from https://stackoverflow.com/questions/56533059/how-to-get-current-location-with-swiftui by Roman Reimche on 13.10.19.
//  Copyright Â© 2019 Roman Reimche. All rights reserved.
//

import Foundation
import Combine
import CoreLocation
import Firebase
import GeoFire

class LocationManager: NSObject, CLLocationManagerDelegate, ObservableObject {
    // TODO add removeAllObservers for the GeoFire somewhere?
    
    private let manager: CLLocationManager
    private var dbRef: DatabaseReference!
    private var geoFire: GeoFire!
    private var session: SessionStore!
    private var circleQuery: GFCircleQuery!
    private var circleQueryHandles: Array<FirebaseHandle> = []
    private var databasePath = "players-online"
    
    // Distance at which two users are though to collide
    let collisionDistance: Double = 3
    var collisionHappened = false
    
    // MARK: ObservableObject
    
    /*var didChange = PassthroughSubject<LocationManager, Never>()

    // TODO CLLocation -> CLLocation?, no marker and appropriate message if nil
    var lastKnownLocation: CLLocation {
        didSet {
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue(true)
            geoFire.setLocation(lastKnownLocation, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery.center = self.lastKnownLocation
            
            // Propagate the update to the observers.
            didChange.send(self)
            print("Finished propagating lastKnownLocation to the observers.")
        }
    }
    
    var nearbyPlayers : Set<User> = [] {
        didSet {
            didChange.send(self)
        }
    }*/
    
    @Published var lastKnownLocation: CLLocation
    typealias DistanceToUser = CLLocationDistance
    @Published var nearbyPlayers : Dictionary<User, DistanceToUser> = [:]

    // MARK: INIT
    
    init(manager: CLLocationManager = CLLocationManager(), session: SessionStore) {
        
        self.manager = manager
        self.dbRef = Database.database().reference()
        self.geoFire = GeoFire(firebaseRef: dbRef)
        self.session = session
        self.lastKnownLocation = CLLocation(latitude: 0, longitude: 0)
        
        super.init()
        
        // Start updating location
        self.manager.delegate = self
        self.manager.requestWhenInUseAuthorization()
        self.manager.startUpdatingLocation()
        
        // Suscribe for events generated by nearby online users (radius is in Kilometers)
        self.circleQuery = self.geoFire.query(at: lastKnownLocation, withRadius: 0.6)

        // Set event processors for the events of other players entering and leayving
        // the nearby zone and for moving inside of it.
        let gfEventProcessors : Dictionary<GFEventType, gfEventProcessor> =
            [.keyEntered : keyEnteredProceessor(key:anotherUserLocation:),
             .keyMoved : keyMovedProcessor(key:anotherUserLocation:),
             .keyExited : keyExitedProcessor(key:anotherUserLocation:) ]
        for (eventType, processor) in gfEventProcessors {
            self.circleQueryHandles.append(circleQuery.observe(eventType, with: processor))
        }
        
    }

//    func startUpdating() {
//        self.manager.delegate = self
//        self.manager.requestWhenInUseAuthorization()
//        self.manager.startUpdatingLocation()
//    }
    
    // MARK: CLLocationManagerDelegate

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        //print(locations)
        
        
        if let newLocation = locations.last {
            print("Location of the local player was updated: \(String(describing: newLocation))")
            
            lastKnownLocation = newLocation
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue(true)
            geoFire.setLocation(lastKnownLocation, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery.center = self.lastKnownLocation
  
        }
        
    }

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedWhenInUse {
            manager.startUpdatingLocation()
        }
    }
    
    // MARK: gfEventProcessors
    
    typealias gfEventProcessor = (String, CLLocation) -> ()
    
    func keyEnteredProceessor(key uid: String, anotherUserLocation: CLLocation) -> () {
        print("Player with uid (key) '\(String(describing: uid))' entered the search area and is at location '\(String(describing: anotherUserLocation))'")

        let anotherUser = User(uid: uid, displayName: nil, email: nil, location: anotherUserLocation)
        let distanceToUser = lastKnownLocation.distance(from: anotherUserLocation)
        
        if distanceToUser.isLessThanOrEqualTo(collisionDistance) {
            print("Local user \(session.user!.uid) and another user \(anotherUser.uid) have collided.")
            collisionHappened = true
        }
        
        self.nearbyPlayers.updateValue(distanceToUser, forKey: anotherUser)
    }
    
    func keyExitedProcessor(key uid: String, anotherUserLocation: CLLocation) -> () {
        print("Player with uid (key) '\(String(describing: uid))' exited the search area and is at location '\(String(describing: anotherUserLocation))'")

        let anotherUser = User(uid: uid, displayName: nil, email: nil, location: anotherUserLocation)

        self.nearbyPlayers.removeValue(forKey: anotherUser)
    }
    
    func keyMovedProcessor(key uid: String, anotherUserLocation: CLLocation) -> () {
        
        switch uid == session.user!.uid {
        case true:
            print("The .keyMoved fired on the local user, nothing to do.")
            
        case false:
            print("Player with uid (key) '\(String(describing: uid))' moved in the search area and is at location '\(String(describing: anotherUserLocation))'")
            
            let anotherUser = User(uid: uid, displayName: nil, email: nil, location: anotherUserLocation)
            let distanceToUser = lastKnownLocation.distance(from: anotherUserLocation)

            self.nearbyPlayers.updateValue(distanceToUser, forKey: anotherUser)
        }

        
    }

// TODO remove
//    let keyEnteredProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' entered the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        self.nearbyPlayers.insert(user)
//    }
//
//    let keyExitedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' exited the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.remove(user)
//
//    }
//
//    let keyMovedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' moved in the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.update(with: user)
//    }
    
}
