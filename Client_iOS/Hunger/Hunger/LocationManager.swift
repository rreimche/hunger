//
//  LocationManager.swift
//  Hunger
//
//  Adapted from https://stackoverflow.com/questions/56533059/how-to-get-current-location-with-swiftui by Roman Reimche on 13.10.19.
//  Copyright Â© 2019 Roman Reimche. All rights reserved.
//

import Foundation
import Combine
import CoreLocation
import Firebase
import GeoFire

class LocationManager: NSObject, CLLocationManagerDelegate, ObservableObject {
    // TODO add removeAllObservers for the GeoFire somewhere?
    
    private let manager: CLLocationManager
    private var dbRef: DatabaseReference!
    private var geoFire: GeoFire!
    private var session: SessionStore!
    private var circleQuery: GFCircleQuery?
    private var circleQueryHandles: Array<FirebaseHandle> = []
    private var databasePath = "players-online"
    
    // Distance at which two users are though to collide
    let collisionDistance: Double = 3
    var collisionHappened = false
    
    // MARK: ObservableObject
    
    /*var didChange = PassthroughSubject<LocationManager, Never>()

    // TODO CLLocation -> CLLocation?, no marker and appropriate message if nil
    var lastKnownLocation: CLLocation {
        didSet {
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue(true)
            geoFire.setLocation(lastKnownLocation, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery.center = self.lastKnownLocation
            
            // Propagate the update to the observers.
            didChange.send(self)
            print("Finished propagating lastKnownLocation to the observers.")
        }
    }
    
    var nearbyPlayers : Set<User> = [] {
        didSet {
            didChange.send(self)
        }
    }*/
    
    @Published var lastKnownLocation: CLLocation
    typealias DistanceToUser = CLLocationDistance
    @Published var nearbyPlayers : Dictionary<User, DistanceToUser> = [:]

    // MARK: INIT
    
    init(manager: CLLocationManager = CLLocationManager(), session: SessionStore) {
        
        self.manager = manager
        self.dbRef = Database.database().reference()
        self.geoFire = GeoFire(firebaseRef: dbRef)
        self.session = session
        self.lastKnownLocation = CLLocation(latitude: 0, longitude: 0)
        
        super.init()
        
        // Start updating location
        self.manager.delegate = self
        self.manager.requestWhenInUseAuthorization()
        
        
    }
    
    // MARK: Start/Stop updating locations
    
    func startUpdatingLocations(){
        self.manager.startUpdatingLocation()
        
        // Suscribe for events generated by nearby online users (radius is in Kilometers)
        self.circleQuery = self.geoFire.query(at: lastKnownLocation, withRadius: 1)

        // Set event processors for the events of other players entering and leayving
        // the nearby zone and for moving inside of it.
        let gfEventProcessors : Dictionary<GFEventType, gfEventProcessor> =
            [.keyEntered : keyEnteredProcessor(key:enteredUserLocation:),
             .keyMoved : keyMovedProcessor(key:movedUserLocation:),
             .keyExited : keyExitedProcessor(key:exitedUserLocation:) ]
        for (eventType, processor) in gfEventProcessors {
            self.circleQueryHandles.append(circleQuery!.observe(eventType, with: processor))
        }
    }
    func stopUpdatingLocations(){
        // TODO stop updating location service and geofire
        self.circleQuery!.removeAllObservers()
        self.manager.stopUpdatingLocation()
    }

//    func startUpdating() {
//        self.manager.delegate = self
//        self.manager.requestWhenInUseAuthorization()
//        self.manager.startUpdatingLocation()
//    }
    
    // MARK: CLLocationManagerDelegate

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        //print(locations)
        
        guard session.user!.playsAs != nil else {
            print("Warning: LocationManager.locationManager(manager:didUpdateLocations:) was called before local user player type was set. The update will not be processed.")
            return
        }
        
        guard self.circleQuery != nil else {
            print("Warning: LocationManager.circleQuery is still nil, but LocationManager.locationManager(manager:didUpdateLocations:) was already called. The update will not be processed.")
            
            return
        }
        
        if let newLocation = locations.last {
            print("Location of the local player was updated: \(String(describing: newLocation))")
            
            lastKnownLocation = newLocation
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue(["playsAs": String(session.user!.playsAs!.rawValue)])
            geoFire.setLocation(lastKnownLocation, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery!.center = self.lastKnownLocation
  
        }
        
    }

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedWhenInUse {
            manager.startUpdatingLocation()
        }
    }
    
    // MARK: gfEventProcessors
    
    typealias gfEventProcessor = (String, CLLocation) -> ()
    
    func keyEnteredProcessor(key enteredUid: String, enteredUserLocation: CLLocation) -> () {
        
        switch enteredUid == session.user!.uid {
            
        case true:
            print("The .keyEntered fired on the local user, nothing to do.")
            
        case false:
            print("Player with uid (key) '\(String(describing: enteredUid))' entered the search area and is at location '\(String(describing: enteredUserLocation))'")
            
            dbRef.child(databasePath + "/" + enteredUid + "playsAs").observeSingleEvent(of: .value, with: { (snapshot) in
                guard let stringUserPlaysAs = snapshot.value as? String else {
                    print ("Warning: playAs of an online player stored in the realtime database seems to be absent. This .keyEnteredEvent will not be processed.")
                    return
                }
                
//                do {
//
//                    let userPlaysAs: PlayAs = try PlayAs(playerType: stringUserPlaysAs)
//
//                } catch PlayAsError.invalidPlayerType(type: stringUserPlaysAs) {
//                    print("Invalid player type when initializing a PlayAs instance:" + stringUserPlaysAs)
//                    return
//                }
                
                let userPlaysAs: PlayAs?

                switch stringUserPlaysAs {
                case "human": userPlaysAs = .human
                case "zombie": userPlaysAs = .zombie
                default: userPlaysAs = nil
                }

                guard userPlaysAs != nil else {
                    print("Invalid player type when initializing a PlayAs instance:" + stringUserPlaysAs + ". Therefore no marker will be placed for this player." )
                    return
                }
                
                let enteredUser = User(uid: enteredUid, displayName: nil, email: nil, location: enteredUserLocation, playsAs: userPlaysAs)
                let distanceToUser = self.lastKnownLocation.distance(from: enteredUserLocation)
                
                if distanceToUser.isLessThanOrEqualTo(self.collisionDistance) {
                    print("Local user \(self.session.user!.uid) and another user \(enteredUser.uid) have collided.")
                    self.collisionHappened = true
                }
                
                self.nearbyPlayers.updateValue(distanceToUser, forKey: enteredUser)
                
            }) { (error) in
                print(error.localizedDescription)
            }

            
        }
        
        
    }
    
    func keyExitedProcessor(key uid: String, exitedUserLocation: CLLocation) -> () {
        print("Player with uid (key) '\(String(describing: uid))' exited the search area and is at location '\(String(describing: exitedUserLocation))'")

        let exitedUser = User(uid: uid, displayName: nil, email: nil, location: exitedUserLocation)

        self.nearbyPlayers.removeValue(forKey: exitedUser)
    }
    
    func keyMovedProcessor(key uid: String, movedUserLocation: CLLocation) -> () {
        
        switch uid == session.user!.uid {
        case true:
            print("The .keyMoved fired on the local user, nothing to do.")
            
        case false:
            print("Player with uid (key) '\(String(describing: uid))' moved in the search area and is at location '\(String(describing: movedUserLocation))'")
            
            let movedUser = User(uid: uid, displayName: nil, email: nil, location: movedUserLocation)
            let distanceToUser = lastKnownLocation.distance(from: movedUserLocation)
            
            
            if distanceToUser.isLessThanOrEqualTo(collisionDistance) {
                print("Local user \(session.user!.uid) and another user \(movedUser.uid) have collided.")
                collisionHappened = true
            }

            self.nearbyPlayers.updateValue(distanceToUser, forKey: movedUser)
        }

        
    }

// TODO remove
//    let keyEnteredProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' entered the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        self.nearbyPlayers.insert(user)
//    }
//
//    let keyExitedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' exited the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.remove(user)
//
//    }
//
//    let keyMovedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' moved in the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.update(with: user)
//    }
    
}
