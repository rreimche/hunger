//
//  LocationManager.swift
//  Hunger
//
//  This class deals with emanaging user locations: tracking of local and others users locations and collision detection between them.
//
//  Adapted from https://stackoverflow.com/questions/56533059/how-to-get-current-location-with-swiftui by Roman Reimche on 13.10.19.
//  Copyright Â© 2019 Roman Reimche. All rights reserved.
//

import Foundation
import Combine
import CoreLocation
import Firebase
import GeoFire

class LocationManager: NSObject, CLLocationManagerDelegate, ObservableObject {
    // TODO add removeAllObservers for the GeoFire somewhere?
    
    private let manager: CLLocationManager
    private var dbRef: DatabaseReference!
    private var geoFire: GeoFire!
    private var session: SessionStore!
    private var circleQuery: GFCircleQuery?
    private var circleQueryHandles: Array<FirebaseHandle> = []
    private let databasePath = "players-online"
    let defaultStartingLocation = CLLocation(latitude: 0, longitude: 0)
    private let circleQueryRadius = 10 // in kilometers
    
    // Distance at which two users are though to collide
    let collisionDistance: Double = 5
    var zombieCollidedWithHuman = false
    
    // MARK: ObservableObject
    
    /*var didChange = PassthroughSubject<LocationManager, Never>()

    // TODO CLLocation -> CLLocation?, no marker and appropriate message if nil
    var lastKnownLocation: CLLocation {
        didSet {
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue(true)
            geoFire.setLocation(lastKnownLocation, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery.center = self.lastKnownLocation
            
            // Propagate the update to the observers.
            didChange.send(self)
            print("Finished propagating lastKnownLocation to the observers.")
        }
    }
    
    var nearbyPlayers : Set<User> = [] {
        didSet {
            didChange.send(self)
        }
    }*/
    
    @Published var lastKnownLocation: CLLocation?
    typealias DistanceToUser = CLLocationDistance
    @Published var nearbyPlayers : Dictionary<User, DistanceToUser> = [:]

    // MARK: INIT
    
    init(manager: CLLocationManager = CLLocationManager(), session: SessionStore) {
        
        self.manager = manager
        self.dbRef = Database.database().reference()
        self.geoFire = GeoFire(firebaseRef: dbRef)
        self.session = session
        //self.lastKnownLocation = CLLocation(latitude: 0, longitude: 0)
        
        super.init()
        
        // Start updating location
        self.manager.delegate = self
        self.manager.requestWhenInUseAuthorization()
        
        
    }
    
    // MARK: Start/Stop updating locations
    
    func startUpdatingLocations(){
        self.manager.startUpdatingLocation()
        
        // Suscribe for events generated by nearby online users (radius is in Kilometers)
        self.circleQuery = self.geoFire.query(at: lastKnownLocation ?? defaultStartingLocation, withRadius: 10)

        // Set event processors for the events of other players entering and leayving
        // the nearby zone and for moving inside of it.
        let gfEventProcessors : Dictionary<GFEventType, gfEventProcessor> =
            [.keyEntered : keyEnteredProcessor(key:enteredUserLocation:),
             .keyMoved : keyMovedProcessor(key:movedUserLocation:),
             .keyExited : keyExitedProcessor(key:exitedUserLocation:) ]
        for (eventType, processor) in gfEventProcessors {
            self.circleQueryHandles.append(circleQuery!.observe(eventType, with: processor))
        }
    }
    func stopUpdatingLocations(){
        // TODO stop updating location service and geofire
        self.circleQuery!.removeAllObservers()
        self.manager.stopUpdatingLocation()
    }

//    func startUpdating() {
//        self.manager.delegate = self
//        self.manager.requestWhenInUseAuthorization()
//        self.manager.startUpdatingLocation()
//    }
    
    // MARK: CLLocationManagerDelegate

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        //print(locations)
        
        guard session.user != nil else {
            print("Warning: StorageSession.user is nil in LocationManager.locationmanager(_:didUpdateWithOptions). The update will not be processed.")
            return
        }
        
        guard session.user!.playsAs != nil else {
            print("Warning: LocationManager.locationManager(manager:didUpdateLocations:) was called before local user player type was set. The update will not be processed.")
            return
        }
        
        guard self.circleQuery != nil else {
            print("Warning: LocationManager.circleQuery is still nil, but LocationManager.locationManager(manager:didUpdateLocations:) was already called. The update will not be processed.")
            
            return
        }
        
        if let newLocation = locations.last {
            print("Location of the local player was updated: \(String(describing: newLocation))")
            
            lastKnownLocation = newLocation
            
            // Post location to firebase.
            self.dbRef.child(databasePath).child(session.user!.uid).setValue([
                "playsAs": String(session.user!.playsAs!.rawValue),
                "lastTimeOnline": ServerValue.timestamp()
            ])
            geoFire.setLocation(lastKnownLocation!, forKey: session.user!.uid){ (error) in
                if (error != nil) {
                    print("An error occured: \(String(describing: error))")
                } else {
                    print("Saved new location of the local player to firebase successfully.")
                }
            }
            
            // Update circleQuery.
            self.circleQuery!.center = self.lastKnownLocation!
  
        }
        
    }

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedWhenInUse {
            manager.startUpdatingLocation()
        }
    }
    
    // MARK: gfEventProcessors
    
    typealias gfEventProcessor = (String, CLLocation) -> ()
    
    func keyEnteredProcessor(key enteredUid: String, enteredUserLocation: CLLocation) -> () {
        
        if enteredUid == session.user!.uid {
            
            print("The .keyEntered fired on the local user, nothing to do.")
            
        } else {
            print("Player with uid (key) '\(String(describing: enteredUid))' entered the search area and is at location '\(String(describing: enteredUserLocation))'")
            
            dbRef.child(databasePath + "/" + enteredUid + "/playsAs").observeSingleEvent(of: .value, with: { (snapshot) in
                guard let stringUserPlaysAs = snapshot.value as? String else {
                    print ("Warning: playAs of a nearby online player stored in the realtime database seems to be absent. This .keyEnteredEvent will not be processed.")
                    return
                }
                
                let userPlaysAs: PlayAs?

                switch stringUserPlaysAs {
                case "human": userPlaysAs = .human
                case "zombie": userPlaysAs = .zombie
                default: userPlaysAs = nil
                }

                guard userPlaysAs != nil else {
                    print("Warning: Invalid player type when initializing a PlayAs instance:" + stringUserPlaysAs + ". Therefore no marker will be placed for this player." )
                    return
                }
                
                let enteredUser = User(uid: enteredUid, displayName: nil, email: nil, location: enteredUserLocation, playsAs: userPlaysAs)
                let distanceToUser = self.lastKnownLocation!.distance(from: enteredUserLocation)
                
                if self.localUserCollidedWithAnotherPlayerType(anotherPlayer: enteredUser) {
                    print("Collision of different types of players happened: Local user \(self.session.user!.uid) (\(self.session.user!.playsAs!)) and another user \(enteredUser.uid) (\(enteredUser.playsAs!)).")
                    self.zombieCollidedWithHuman = true
                }
        
                
                //self.nearbyPlayers.updateValue(distanceToUser, forKey: enteredUser)
                self.nearbyPlayers[enteredUser] = distanceToUser
                
            }) { (error) in
                print(error.localizedDescription)
            }

            
        }
        
        
    }
    
    func keyExitedProcessor(key uid: String, exitedUserLocation: CLLocation) -> () {
        print("Player with uid (key) '\(String(describing: uid))' exited the search area and is at location '\(String(describing: exitedUserLocation))'")

        let exitedUser = User(uid: uid, displayName: nil, email: nil, location: exitedUserLocation)

        self.nearbyPlayers.removeValue(forKey: exitedUser)
    }
    
    func keyMovedProcessor(key movedUid: String, movedUserLocation: CLLocation) -> () {
        
        if movedUid == session.user!.uid {
        
            print("The .keyMoved fired on the local user, nothing to do.")
            
        } else {
            
            print("Player with uid (key) '\(String(describing: movedUid))' moved in the search area and is at location '\(String(describing: movedUserLocation))'")
            
            dbRef.child(databasePath + "/" + movedUid + "/playsAs").observeSingleEvent(of: .value, with: { (snapshot) in
                guard let stringUserPlaysAs = snapshot.value as? String else {
                    print ("Warning: playAs of a nearby online player stored in the realtime database seems to be absent. This .keyMovedEvent will not be processed.")
                    return
                }
                
                let userPlaysAs: PlayAs?

                switch stringUserPlaysAs {
                case "human": userPlaysAs = .human
                case "zombie": userPlaysAs = .zombie
                default: userPlaysAs = nil
                }

                guard userPlaysAs != nil else {
                    print("Warning: Invalid player type when initializing a PlayAs instance:" + stringUserPlaysAs + ". Therefore no marker will be placed for this player." )
                    return
                }
                
                let movedUser = User(uid: movedUid, displayName: nil, email: nil, location: movedUserLocation, playsAs: userPlaysAs)
                let distanceToUser = self.lastKnownLocation!.distance(from: movedUserLocation)
                
                
                if self.localUserCollidedWithAnotherPlayerType(anotherPlayer: movedUser) {
                    print("Collision of different types of players happened: Local user \(self.session.user!.uid) (\(self.session.user!.playsAs!)) and another user \(movedUser.uid) (\(movedUser.playsAs!)).")
                    self.zombieCollidedWithHuman = true
                }

                //self.nearbyPlayers.updateValue(distanceToUser, forKey: movedUser)
                self.nearbyPlayers[movedUser] = distanceToUser
            }) { (error) in
                print(error.localizedDescription)
            }
        
        }

        
    }

// TODO remove
//    let keyEnteredProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' entered the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        self.nearbyPlayers.insert(user)
//    }
//
//    let keyExitedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' exited the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.remove(user)
//
//    }
//
//    let keyMovedProcessor : gfEventProcessor = {(key: String!, location: CLLocation) -> Void in
//
//        print("Key '\(String(describing: key))' moved in the search area and is at location '\(String(describing: location))'")
//
//        let uid = key
//
//        let user = User(uid: uid!, displayName: nil, email: nil, location: location)
//
//        nearbyPlayers.update(with: user)
//    }
    
    // MARK: Helper functions
    
    func localUserCollided(withUserAtLocation otherUsersLocation: CLLocation ) -> Bool {
        let distanceToUser = lastKnownLocation!.distance(from: otherUsersLocation)
        
        return distanceToUser.isLessThanOrEqualTo(collisionDistance)
    }
    
    func localUserCollidedWithAnotherPlayerType(anotherPlayer: User) -> Bool {
        return (localUserCollided(withUserAtLocation: anotherPlayer.location!)
            && session.user!.playsAs! != anotherPlayer.playsAs!)
    }
    
}
